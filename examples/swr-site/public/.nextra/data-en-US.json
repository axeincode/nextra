{"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your React project directory, run the following:\nyarn add swr\nOr with npm:\nnpm install swr","quick-start#Quick Start":"For normal RESTful APIs with JSON data, first you need to create a fetcher function, which is just a wrapper of the native fetch:\nconst fetcher = (...args) => fetch(...args).then(res => res.json())\n\nIf you want to use GraphQL API or libs like Axios, you can create your own fetcher function.\nCheck here for more examples.\nThen you can import useSWR and start using it inside any function components:\nimport useSWR from 'swr'\n\nfunction Profile () {\nconst { data, error } = useSWR('/api/user/123', fetcher)\n\nif (error) return <div>failed to load</div>\nif (!data) return <div>loading...</div>\n\n// render data\nreturn <div>hello {data.name}!</div>\n}\nNormally, there're 3 possible states of a request: \"loading\", \"ready\", or \"error\". You can use the value of data and error to\ndetermine the current state of the request, and return the corresponding UI.","make-it-reusable#Make It Reusable":"When building a web app, you might need to reuse the data in many places of the UI. It is incredibly easy to create reusable data hooks\non top of SWR:\nfunction useUser (id) {\nconst { data, error } = useSWR(`/api/user/${id}`, fetcher)\n\nreturn {\nuser: data,\nisLoading: !error && !data,\nisError: error\n}\n}\nAnd use it in your components:\nfunction Avatar ({ id }) {\nconst { user, isLoading, isError } = useUser(id)\n\nif (isLoading) return <Spinner />\nif (isError) return <Error />\nreturn <img src={user.avatar} />\n}\nBy adopting this pattern, you can forget about fetching data in the imperative way: start the request, update the loading state, and return the final result.\nInstead, your code is more declarative: you just need to specify what data is used by the component.","example#Example":"In a real-world example, our website shows a navbar and the content, both depend on user:\n\n\n\nTraditionally, we fetch data once using useEffect in the top level component, and pass it to child components via props (notice that we don't handle error state for now):\n// page component\n\nfunction Page () {\nconst [user, setUser] = useState(null)\n\n// fetch data\nuseEffect(() => {\nfetch('/api/user')\n.then(res => res.json())\n.then(data => setUser(data))\n}, [])\n\n// global loading state\nif (!user) return <Spinner/>\n\nreturn <div>\n<Navbar user={user} />\n<Content user={user} />\n</div>\n}\n\n// child components\n\nfunction Navbar ({ user }) {\nreturn <div>\n...\n<Avatar user={user} />\n</div>\n}\n\nfunction Content ({ user }) {\nreturn <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar ({ user }) {\nreturn <img src={user.avatar} alt={user.name} />\n}\nUsually, we need to keep all the data fetching in the top level component and add props to every component deep down the tree.\nThe code will become harder to maintain if we add more data dependency to the page.Although we can avoid passing props using Context, there's still the dynamic content problem:\ncomponents inside the page content can be dynamic, and the top level component might not know what data will be needed by its child components.SWR solves the problem perfectly. With the useUser hook we just created, the code can be refactored to:\n// page component\nfunction Page () {\nreturn <div>\n<Navbar />\n<Content />\n</div>\n}\n\n// child components\nfunction Navbar () {\nreturn <div>\n...\n<Avatar />\n</div>\n}\n\nfunction Content () {\nconst { user, isLoading } = useUser()\nif (isLoading) return <Spinner />\nreturn <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar () {\nconst { user, isLoading } = useUser()\nif (isLoading) return <Spinner />\nreturn <img src={user.avatar} alt={user.name} />\n}\nData is now bound to the components which need the data, and all components are independent to each other.\nAll the parent components don't need to know anything about the data or passing data around. They just render.\nThe code is much simpler and easier to maintain now.The most beautiful thing is that there will be only 1 request sent to the API, because they use the same SWR key and\nthe request is deduped, cached and shared automatically.Also, the application now has the ability to refetch the data on user focus or network reconnect!\nThat means, when the user's laptop wakes from sleep or they switch between browser tabs, the data will be refreshed automatically."}}}